container AfleidingPandtype
{
	unit<uint8> WP5 := WoningtypeSnapshot;
	container results
	{
		attribute<uint32>        nr_buurpanden     (pand) := functioneel_pand/NeighbourCount[invert(functioneel_pand/org_rel)]; 
		attribute<WP5>           WP5_rel           (pand) := functioneel_pand/WP5_rel[invert(functioneel_pand/org_rel)];
	}

	container extents
	{
		attribute<rdc_meter>    NW     (pand) := lower_bound(geometry);
		attribute<rdc_meter>    SE     (pand) := upper_bound(geometry);
		attribute<float64>      X_ext  (pand) := PointCol(SE) - PointCol(NW);
		attribute<float64>      Y_ext  (pand) := PointRow(SE) - PointRow(NW);
	}
	
	
	unit<uint32> functioneel_pand := select_with_org_rel(pand/vbo_count > 0 && extents/X_ext < 1000d && extents/Y_ext < 1000d)
	{
		attribute<rdc_meter>    geometry (poly) := org_rel -> geometry;
		attribute<rdc_meter>    NW              := extents/NW[org_rel];
		attribute<rdc_meter>    SE              := extents/SE[org_rel];
	
		attribute<uint32> NeighbourCount   := pcount(unique_neighbour_pair/F1) + pcount(unique_neighbour_pair/F2);
		attribute<bool>   HasOneNeighbour  := NeighbourCount == 1;
		attribute<bool>   IsSemiAttached   := HasOneNeighbour &&
			HasOneNeighbour[
				MakeDefined(
					unique_neighbour_pair/F2[invert(unique_neighbour_pair/F1)],
					unique_neighbour_pair/F1[invert(unique_neighbour_pair/F2)]
				)
			];

		attribute<uint32> nr_woning := sum_uint32(VBO/gebruiksdoelen/woon, vbo/pand_rel)[org_rel];

		attribute<WP5> WP5_rel  :=
			  nr_woning == 0      ? WP5/V/geen_woonpand
			: nr_woning >  1      ? WP5/V/meergezinspand
			: NeighbourCount == 0 ? WP5/V/vrijstaand
			: HasOneNeighbour
				? IsSemiAttached
					? WP5/V/twee_onder_1_kap
					: WP5/V/hoekwoning
			: WP5/V/tussenwoning;
	}

	parameter<uint32>  nr_x         :=   7;
	parameter<uint32>  nr_y         :=  13;
	parameter<float64> inflate_size := 0.2d; //in meters

	unit<uint32> rectangle := range(uint32, 0, nr_x * nr_y)
	{
		attribute<uint32> seq_y  := id(.) / nr_x;
		attribute<uint32> seq_x  := id(.) % nr_x;
		attribute<string> name   := 'R'+string(seq_y)+'_C'+string(seq_x);

		parameter<uint32> size_x := uint32(pointcol(BoundRange(rdc_meter))) / uint32(nr_x);
		parameter<uint32> size_y := uint32(pointrow(BoundRange(rdc_meter))) / uint32(nr_y);

		attribute<uint32> min_x  := uint32(pointcol(lowerbound(rdc_meter))) + seq_x * size_x;
		attribute<uint32> max_x  := min_x + size_x;
		attribute<uint32> min_y  := uint32(pointrow(lowerbound(rdc_meter))) + seq_y * size_y;
		attribute<uint32> max_y  := min_y + size_y;
	}

	container rectangles := for_each_ne(rectangle/name, 'Connect_neighbours_T('+string(ID(rectangle))+')');

	template Connect_neighbours_T
	{
		parameter<rectangle> rectangle_sel;
		// end case parameters

		unit<uint32> domain :=
			select_with_org_rel(
				uint32(PointCol(functioneel_pand/NW)) <= rectangle/max_x[rectangle_sel]
			&&	uint32(PointRow(functioneel_pand/NW)) <= rectangle/max_y[rectangle_sel]
			&&	uint32(PointCol(functioneel_pand/SE)) >= rectangle/min_x[rectangle_sel]
			&&	uint32(PointRow(functioneel_pand/SE)) >= rectangle/min_y[rectangle_sel]
			)
		{
			// attribute<rdc_meter> geometry (poly) := org_rel -> geometry;
		}

		attribute<rdc_meter> buffer (domain, poly) := bg_buffer_multi_polygon(domain/org_rel -> functioneel_pand/geometry, inflate_size, 4b); 

		unit<uint32> neighbours := polygon_connectivity(buffer[rdc_cm])
		{
			attribute<upoint> coded_pair := point(domain/org_rel[F1], domain/org_rel[F2]);
		}
	}
	
	unit<uint32> neighbour_pair := ='union_unit('+AsItemList('rectangles/' + rectangle/name + '/neighbours')+')'
	{
		attribute<upoint> coded_pair := ='union_data(., '+AsItemList('rectangles/' + rectangle/name + '/neighbours/coded_pair')+')';
	}
	
	unit<uint32> unique_neighbour_pair := unique(neighbour_pair/coded_pair)
	{
		attribute<functioneel_pand> F1 := pointrow(values)[functioneel_pand];
		attribute<functioneel_pand> F2 := pointcol(values)[functioneel_pand];
	}
}
